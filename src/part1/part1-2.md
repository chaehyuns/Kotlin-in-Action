# 코인액 (Kotlin in Action) 정리 Part1 #2

---
### 개요
![](https://velog.velcdn.com/images/wjdcogus6/post/5dfeddbf-c18c-4f83-89de-f7abec1c0c7e/image.png)
오늘도 코인액 part1을 이어서 정리하도록 하겠습니다.


#### **오늘의 요약**
> **코틀린은 객체 지향 프로그래밍과 풍부한 함수형 프로그래밍을 지원한다.**
> (다중 패러다임 언어)

---

### 함수형 프로그래밍
코인액에서는 java를 아는 사람의 기준으로 kotlin을 설명하기 때문에 객체 지향에 대한 이야기는 생략되어있으며 함수형 프로그래밍에 대한 이야기를 중심적으로 코틀린의 장점을 설명한다.

함수형 프로그래밍의 가장 큰 특징은 아래와 같습니다.
> 순수 함수를 일급 시민(first-class)으로 취급한다.

일급 시민? 이라는 궁금증이 당연히 생기겠죠.

단순히 아래와 같이 이해를 하면 됩니다.

부수 효과가 없는 순수 함수를 1급 객체로 간주하여 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.

그러니까 말 그대로 신원 보증이 확실하므로 함수를 자유롭게 사용할 수 있는 것이죠.

#### 어떻게 그럴 수 있을까요?
내부 상태가 절대로 바뀌지 않는 불변 객체를 사용하며,
입력이 같으면 항상 같은 출력을 내놓는 순수 함수 덕분입니다.

#### 그러면 왜 코틀린이 함수형 프로그래밍을 지원하는게 장점일까요?
순수 함수를 값처럼 사용하면 **간결하게 강력한 추상화**를 할 수 있고 (예측이 가능하고, 재사용성이 좋기 때문에)
데이터가 불변하기 때문에 **다중 스레드를 사용해도 안전**하며
독립적으로 테스트 할 수 있으므로 **테스트하기 쉽기** 때문입니다.

#### 어떻게 코틀린은 함수형 프로그래밍을 지원할까요?
함수를 파라미터로 받거나 반환 가능
람다식 지원
데이터 클래스를 만드는 간편한 구문 제공
.
.

#### 코틀린 함수형 프로그래밍(고차 함수)사용의 예시
map을 사용한 고차 함수 예시를 들어보겠습니다.
``` kotlin
// 정수 리스트
val numbers = listOf(1, 2, 3, 4, 5)

// 각 숫자의 제곱을 계산하는 함수
fun square(n: Int): Int = n * n

// map 함수를 사용하여 각 요소에 함수 적용
val squares = numbers.map(::square)

println(squares) // 출력: [1, 4, 9, 16, 25]

```

---

### 객체 지향 프로그래밍
그러면 이제 책에서 설명해주지 않는 객체 지향 프로그래밍에 대해서도 알아보겠습니다.
코틀린은 객체 지향 프로그래밍(OOP)의 강력한 특징을 가지고 있어, 개발자가 더욱 강력하고 유연한 코드를 작성할 수 있게 합니다. OOP는 코드를 객체로 구성하여, 현실 세계의 사물이나 개념을 프로그래밍적으로 모델링하는 방법론입니다.

#### 객체 지향 프로그래밍의 핵심 개념
* **캡슐화**: 데이터(속성)와 그 데이터를 처리하는 코드(메소드)를 하나로 묶어 객체를 만듭니다. 이렇게 하면 정보 은닉이 가능해지며, 객체의 세부 구현을 외부에서 알 필요 없이 사용할 수 있습니다.

* **상속**: 한 클래스의 속성과 메소드를 다른 클래스가 물려받을 수 있습니다. 이는 코드 재사용성을 높이고, 계층적인 구조를 만들어 프로그램의 구조를 명확하게 합니다.

* **다형성**: 같은 이름의 메소드가 다양한 방식으로 동작할 수 있도록 합니다. 이는 코드의 유연성을 높이고, 새로운 형태의 객체가 추가되어도 기존 시스템을 변경하지 않고 확장할 수 있게 해줍니다.

* **추상화**: 복잡한 현실 세계의 사물이나 개념을 단순화하여 모델링하는 과정입니다. 프로그램 내에서 필요한 핵심적인 특징만을 추출하여 표현함으로써, 복잡성을 관리할 수 있습니다.

---

### 코틀린에서의 객체 지향 프로그래밍
코틀린은 객체 지향을 더욱 편리하고 안전하게 사용할 수 있는 여러 기능을 제공합니다

* **클래스와 인스턴스**: 코틀린에서 클래스를 정의하고, 해당 클래스의 인스턴스를 생성하여 작업을 수행할 수 있습니다.

* **프로퍼티와 메소드**: 클래스 내에 데이터를 저장하는 프로퍼티와 행동을 정의하는 메소드를 쉽게 정의할 수 있습니다.

* **데이터 클래스**: 데이터를 보유하는 목적으로 간편하게 클래스를 생성할 수 있습니다. 이는 equals(), hashCode(), toString() 등의 메소드가 자동으로 생성되어 관리가 편리합니다.

* **상속과 인터페이스**: 코틀린은 강력한 상속 구조를 지원하며, 인터페이스를 통해 다형성을 구현할 수 있습니다.

#### 객체 지향의 장점
* **구조화된 코드**: 각 객체는 명확한 역할과 책임을 가집니다. 이는 코드의 구조를 명확하게 하고, 이해하기 쉬운 프로그램을 만들 수 있게 합니다.

* **재사용성**: 기존의 코드를 쉽게 재사용할 수 있어 개발 시간과 비용을 절약할 수 있습니다.

* **확장성**: 시스템을 확장하거나 변경할 때 기존 코드에 큰 영향을 주지 않고 개선할 수 있습니다.

---

### 결론
코틀린은 객체 지향 프로그래밍과 함수형 프로그래밍의 장점을 모두 갖춘 언어입니다.

명령형 프로그래밍(객체 지향<span style="color: gray">, 절차 지향</span>)과 선언형 프로그래밍(함수형)을 모두 사용할 수 있다는 말과 동일합니다.

이를 통해 개발자는 강력하고 유연하며, 유지보수가 쉬운 코드를 작성할 수 있습니다.

객체 지향 프로그래밍을 통해 구조화된 코드를 작성하고,
함수형 프로그래밍을 통해 안전하고 간결한 코드를 작성할 수 있습니다. 







